---
title: "iOSアプリで時間のかかる処理をする"
emoji: "🌈"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ios, swift, thread]
published: false
---

iOSアプリで時間のかかる処理が発生すると何が起こるのでしょうか？

# 時間のかかる処理

例えば、以下のような画面が表示されているアプリがあったとして、「Push Me!」のボタンをタップすると、

![](https://storage.googleapis.com/zenn-user-upload/d3e323786c74-20221025.png =200x)

地球のアイコンがインジケーターに変わって回転のアニメーションが始まり、何か処理を行なっている様子を感じ取れます。しばらくすると、インジケーターが地球のアイコンに戻り、処理が完了した様子を感じ取れます。

![](https://storage.googleapis.com/zenn-user-upload/da0395ed118b-20221025.png =200x)

iOSアプリでは、至る所にユーザに対してアニメーションのフィードバックを返して何が起こっているのか絶えずユーザに伝える工夫がなされており、 Apple もそれを推奨しています。

このアプリで採用しているインジケーターは Progress Indicators の一種になり、 Human Interface Guidelines にも記載があります。

https://developer.apple.com/design/human-interface-guidelines/components/status/progress-indicators

さて、実は以下の画面でも上記と同じように処理を行なっているのですが、何か処理が始まっても地球のアイコンのままでインジケーターに変わりません。しばらくすると、同じように処理は完了するようですが、アニメーションがないため、いつ完了したのかわかりません。ユーザからするとアプリが固まったように見えます。

![](https://storage.googleapis.com/zenn-user-upload/ba41f82694e8-20221025.png =200x)

# 一体何が起こっているのか？

コンピュータの基本に立ち戻ると、 iOS アプリも**入力・処理・出力**を繰り返して制御しています。このうちの入力と出力に注目してみます。

iOS アプリを含むモバイルアプリは、デバイスに搭載されている**ディスプレイから入力を受け取り、処理結果の出力を行っています**。**このディスプレイという入出力ソースは1つ**しかないことがほとんどです。モバイルアプリでは、メインスレッドというプログラムからの命令を受け付ける一本の流れが用意されています。時間のかかる処理がないようなアプリにおいては、このメインスレッドを意識する必要がないケースもあります。

このメインスレッドで受け付けた命令は順番に処理を実行するため、時間のかかる処理が発生した場合、その間処理が止まり、画面の更新ができなくなるため、固まったように見えてしまいます。

## スレッドとは

- アプリケーションは一度に一つの処理しかできません。
- この一つの処理を実行可能な処理単位としてスレッドと呼んでいます。

# どうすれば良い？

そこで、時間のかかる処理に対しては、メインスレッドとは別のスレッドを用意して、処理を委譲することが可能になっています。

時間のかかる処理をメインスレッドとは別のスレッドに任せることで、画面の更新を行いつつ、時間のかかる処理を並行して行い、処理が完了したら、その結果を画面に反映する、といったことが可能になっています。

この時問題になるのは、このようにしてメインスレッドとは別のスレッドを複数作成して、前述の限られた入出力ソースへのアクセスも行おうとすると、マルチスレッドプログラミングでの課題に向き合う必要が生じます。排他制御、同期制御、デッドロックなど。これを避けるためにも、モバイルアプリでは、メインスレッド以外での入出力ソースへのアクセスを禁止しています。

## マルチスレッドとは

- メインスレッドとは別のスレッドを複数作成して、複数のスレッドを利用すること

そのため、時間のかかる処理を別スレッドに委譲し、処理結果を出力する際はメインスレッドへの切り戻しが必要になっています。

iOS においてこれを楽に実現できるように、 Grand Central Dispatch という仕組みがあります。

https://developer.apple.com/documentation/dispatch/dispatchqueue

時間のかかる処理を行いたい時に `DispatchQueue.global().async` のクロージャに渡すことでキューに処理を渡せます。この宣言で別のスレッドに切り替わるので、メインスレッドの処理を中断することを回避できます。

```swift
DispatchQueue.global().async {
  // 時間のかかる処理
}
```

メインスレッドで画面の更新を行いたい時に `DispatchQueue.main.async` のクロージャに渡すことでキューに処理を渡せます。この宣言でメインスレッドに切り替わるので、画面の更新を行えるようになります。 iOS ではメインスレッド以外での画面の更新を禁止しているので必要な切り替え処理になっています。

```swift
DispatchQueue.main.async {
  // 画面の更新
}
```

たったこれだけで、ここまで書いてきたことの詳細に触れずにマルチスレッドの恩恵を受けることができるようになっています。つまり、時間のかかる処理が発生してもアプリが固まってしまうことを回避できます。

# Swift Concurrency

Swift Concurrency を利用するとここまで述べてきたことも気にしなくて良くなります。

```swift
await doSomething() // 時間のかかる処理
// 画面の更新
```

たったこれだけになります。 `await` のキーワードでスレッドを意識しないで、時間のかかる処理の結果を待ち、処理が完了したら画面の更新をすれば良いだけになります。

ただし、これを実行しているのがメインスレッドである場合に限るので、別のコードがこの処理をメインスレッド以外で呼んでいた場合は、画面の更新ではやはり、メインスレッドの切り替えは必要になります。

# 参考文献

Swift ではなく、 Objective-C について書かれた書籍ですが、 Grand Central Dispatch について詳しいです。

- [エキスパートObjective-Cプログラミング　-iOS/OS Xのメモリ管理とマルチスレッド-](https://book.impress.co.jp/books/3109)

# 関連記事

- [UI 関連の機能はメインスレッドで実行すること : Objective-C プログラミング](https://ez-net.jp/article/D9/pFIzkE5B/-augKeCpM4zZ/)
- [macOS/iOSスレッドプログラミング（ThreadとRunLoop）](https://qiita.com/cubenoy22/items/098a90133dfdc3f33ccc)

# デモアプリ

デモアプリのリポジトリは以下になります。
デモの動画もリンク先で確認可能です。

- [GitHub リポジトリのリンク]()
